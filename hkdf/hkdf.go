// crypto-go: cryptography primitives and wrappers
// Copyright 2025 Dark Bio AG. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package hkdf provides HKDF-SHA256 key derivation.
//
// https://datatracker.ietf.org/doc/html/rfc5869
package hkdf

import (
	"crypto/sha256"
	"io"

	"golang.org/x/crypto/hkdf"
)

// Key derives a key of length n from the secret, salt, and info using
// HKDF-SHA256. The salt and info may be nil or empty.
//
// Panics if n exceeds the maximum output length for SHA-256 HKDF, which is
// 255 * 32 = 8160 bytes.
func Key(secret, salt, info []byte, n int) []byte {
	r := hkdf.New(sha256.New, secret, salt, info)
	out := make([]byte, n)
	if _, err := io.ReadFull(r, out); err != nil {
		panic("hkdf: " + err.Error())
	}
	return out
}

// Extract generates a pseudorandom key for use with Expand from an input secret
// and an optional independent salt.
//
// Only use this function if you need to reuse the extracted key with multiple
// Expand invocations and different context values. Most common scenarios, including
// the generation of multiple keys, should use Key instead.
func Extract(secret, salt []byte) [32]byte {
	blob := hkdf.Extract(sha256.New, secret, salt)
	if len(blob) != 32 {
		panic("hkdf: incorrect pseudorandom key length")
	}
	var prk [32]byte
	copy(prk[:], blob)
	return prk
}

// Expand derives a key, using the given pseudorandom key and optional context
// info, skipping the extraction step.
//
// The pseudorandomKey should have been generated by Extract, or be a uniformly
// random or pseudorandom cryptographically strong key. See RFC 5869, Section 3.3.
// Most common scenarios will want to use Key instead.
func Expand(prk [32]byte, info []byte, n int) []byte {
	r := hkdf.Expand(sha256.New, prk[:], info)
	out := make([]byte, n)
	if _, err := io.ReadFull(r, out); err != nil {
		panic("hkdf: " + err.Error())
	}
	return out
}
